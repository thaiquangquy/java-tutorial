### **Behavioral Patterns**

| Pattern | Problem | Solution | Applicability | Pros & Cons | Comparison |
|---------|---------|----------|--------------|------------|------------|
| **Chain of Responsibility** | How to pass a request along a chain of handlers? | Lets multiple handlers process a request dynamically. | When multiple objects may handle a request. | ✅Decouples sender and receiver<br>✅Flexible request handling<br>❌Can lead to debugging issues | Unlike Observer, it ensures only one handler processes the request. |
| **Command** | How to encapsulate requests as objects? | Encapsulates an operation as an object to execute later. | When implementing undo/redo or job queues. | ✅Supports undo functionality<br>✅Decouples sender from receiver<br>❌Can introduce complexity | Unlike Strategy, which selects behavior, Command stores operations. |
| **Iterator** | How to traverse a collection without exposing its structure? | Provides a standardized way to iterate over collections. | When working with different collection types. | ✅Simplifies traversal<br>✅Encapsulates iteration logic<br>❌May not be needed for simple loops | Unlike Composite, which structures elements hierarchically. |
| **Mediator** | How to reduce direct communication between objects? | Centralizes communication between objects. | When multiple objects interact in complex ways. | ✅Reduces coupling<br>✅Simplifies communication<br>❌Mediator can become complex | Unlike Observer, which notifies multiple subscribers. |
| **Memento** | How to save and restore an object's state? | Captures and restores an object's internal state. | When implementing undo functionality. | ✅Preserves encapsulation<br>✅Supports history tracking<br>❌Consumes memory | Unlike Command, it stores state instead of commands. |
| **Observer** | How to notify multiple objects of state changes? | Defines a subscription mechanism for object updates. | When multiple objects need updates on changes. | ✅Supports event-driven systems<br>✅Decouples subjects from observers<br>❌Can lead to performance issues | Unlike Mediator, which centralizes communication. |
| **State** | How to change object behavior based on its state? | Encapsulates state changes in separate classes. | When an object has complex state-dependent behavior. | ✅Simplifies logic<br>✅Improves maintainability<br>❌Can create multiple small classes | Unlike Strategy, which selects algorithms, State changes behavior. |
| **Strategy** | How to select an algorithm at runtime? | Defines a family of interchangeable algorithms. | When multiple algorithms are needed dynamically. | ✅Encapsulates behavior<br>✅Promotes code reuse<br>❌Increases number of classes | Unlike State, it doesn’t store object state. |
| **Template Method** | How to define a framework where steps can vary? | Defines a method structure but allows subclass customization. | When parts of an algorithm should be customizable. | ✅Promotes code reuse<br>✅Encapsulates common logic<br>❌May force unnecessary subclassing | Unlike Strategy, which allows dynamic switching. |
| **Visitor** | How to perform operations on objects without modifying their structure? | Defines new operations separately from object structure. | When needing new operations without modifying existing classes. | ✅Encapsulates behavior<br>✅Eases adding new operations<br>❌Breaks encapsulation | Unlike Decorator, which modifies behavior dynamically. |

Source: [refactoring.guru](https://refactoring.guru/design-patterns/behavioral-patterns)